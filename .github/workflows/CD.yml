name: Continuous Deployment Pipeline
#  OPTIMIZED FOR AWS FREE TIER ONLY 
# This pipeline uses only free tier services:
# - S3 Static Website Hosting (5GB storage + 15GB transfer/month)
# - EC2 t2.micro instances (750 hours/month = 1 instance full-time)
# Removed costly services: CloudFront, backup buckets, cache invalidations

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    # Handle both workflow_run and manual triggers
    environment:
      name: staging
    steps:
      - name: Debug workflow trigger (for troubleshooting)
        run: |
          echo "=== DEBUGGING WORKFLOW TRIGGER ==="
          echo "Event name: ${{ github.event_name }}"
          echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
          echo "Workflow run head branch: ${{ github.event.workflow_run.head_branch }}"
          echo "Triggering workflow name: ${{ github.event.workflow_run.name }}"
          echo "Triggering workflow ID: ${{ github.event.workflow_run.id }}"
          echo "Repository: ${{ github.repository }}"
          echo "================================="

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Dynamic ref based on trigger type - ensures we get the right commit
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      # AWS credential configuration for staging deployment
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Since we removed build artifacts from CI, we need to rebuild here
      - name: Setup Node.js for deployment builds
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            ./frontend/package-lock.json
            ./API/package-lock.json

      - name: Build Frontend for deployment
        working-directory: ./frontend
        env:
          # Frontend environment variables for build process
          REACT_APP_API_URL: https://${{ secrets.EC2_PRODUCTION_API }}
          REACT_APP_API_BASE_URL: https://${{ secrets.EC2_PRODUCTION_API }}/api
          REACT_APP_ENVIRONMENT: staging
          # Add other frontend environment variables as needed
        run: |
          echo "Building frontend for deployment..."
          npm install --no-fund --no-audit
          DISABLE_ESLINT_PLUGIN=true CI=false npm run build
          echo "Frontend build completed"

      - name: Build API for deployment
        working-directory: ./API
        run: |
          echo "Building API for deployment..."
          npm install --production --no-fund --no-audit
          echo "API build completed"

      - name: Create deployment artifacts
        run: |
          echo "Creating deployment artifacts..."
          mkdir -p dist
          
          # Create version info
          echo "$(date +'%Y%m%d%H%M%S')-${GITHUB_SHA::8}" > dist/version.txt
          
          # Frontend artifacts
          mkdir -p dist/frontend
          if [ -d "frontend/build" ]; then
            cp -r frontend/build/* dist/frontend/
            echo "Frontend artifacts created"
          else
            echo "Frontend build not found"
            exit 1
          fi
          
          # API artifacts
          mkdir -p dist/api
          cp -r API/* dist/api/
          echo "API artifacts created"

      # Deploy Frontend to S3 (Staging) - Using supported S3 sync action
      - name: Deploy Frontend to S3 Staging
        uses: jakejarvis/s3-sync-action@v0.5.1
        with:
          args: --delete
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_STAGING_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SOURCE_DIR: dist/frontend
          
      # Deploy API to EC2 (Staging) - COMMENTED OUT to stay within free tier
      # Only frontend goes to staging, API only deploys to production EC2
      # - name: Deploy API to EC2 Staging
      #   run: |
      #     echo "===== DEPLOYING API TO EC2 STAGING INSTANCE ====="
      #     echo " WARNING: Ensure EC2 instance is t2.micro to stay within free tier"
      #     
      #     # Create deployment package
      #     cd dist/api
      #     tar -czf ../api-deployment.tar.gz .
      #     cd ../..
      #     
      #     # Copy to EC2 instance
      #     echo "Copying API files to EC2 staging instance..."
      #     scp -i ${{ secrets.EC2_SSH_KEY_PATH }} -o StrictHostKeyChecking=no \
      #       dist/api-deployment.tar.gz \
      #       ${{ secrets.EC2_STAGING_USER }}@${{ secrets.EC2_STAGING_API_HOST }}:/tmp/
      #     
      #     # Deploy on EC2 instance
      #     ssh -i ${{ secrets.EC2_SSH_KEY_PATH }} -o StrictHostKeyChecking=no \
      #       ${{ secrets.EC2_STAGING_USER }}@${{ secrets.EC2_STAGING_API_HOST }} << 'EOF'
      #       cd /opt/traffic-guardian-api
      #       sudo systemctl stop traffic-guardian-api || true
      #       sudo rm -rf backup && sudo mv current backup 2>/dev/null || true
      #       sudo mkdir -p current
      #       cd current
      #       sudo tar -xzf /tmp/api-deployment.tar.gz
      #       sudo npm install --production
      #       sudo systemctl start traffic-guardian-api
      #       sudo systemctl enable traffic-guardian-api
      #     EOF
      #     
      #     echo " API deployed to EC2 staging instance"

      # AWS verification using improved health checks
      - name: Verify AWS Staging Deployment
        run: |
          echo "===== VERIFYING AWS STAGING DEPLOYMENT ====="
          echo "Running staging health checks..."
          
          # S3 Static Website health check
          echo "Checking Frontend (S3 Static Website)..."
          FRONTEND_URL="https://${{ secrets.AWS_S3_STAGING_BUCKET }}.s3-website-${{ secrets.AWS_REGION }}.amazonaws.com"
          if curl -f -s --head "$FRONTEND_URL" > /dev/null; then
            echo "  Frontend service: HEALTHY"
          else
            echo "  Frontend service: WARNING - Could not verify"
          fi
          
          # API health check - COMMENTED OUT (no staging EC2 cost restrictions)
          # echo "Checking API (EC2)..."
          # API_URL="https://${{ secrets.EC2_PRODUCTION_API }}/api/health"
          # if curl -f -s "$API_URL" | grep -q '"status":"OK"' 2>/dev/null; then
          #   echo "  API service: HEALTHY"
          # else
          #   echo "  API service: WARNING - Could not verify health endpoint"
          # fi
          
          echo "Staging verification completed! (Frontend only - API tests in production)"

  deploy-production:
    name: Deploy to Production
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    # Handle both workflow_run and manual triggers
    environment:
      name: production
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Dynamic ref based on trigger type - ensures we get the right commit
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      # AWS credential configuration for production deployment
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Build artifacts for production deployment
      - name: Setup Node.js for production builds
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: |
            ./frontend/package-lock.json
            ./API/package-lock.json

      - name: Build Frontend for production
        working-directory: ./frontend
        env:
          # Frontend environment variables for production build
          REACT_APP_API_URL: https://${{ secrets.EC2_PRODUCTION_API }}
          REACT_APP_API_BASE_URL: https://${{ secrets.EC2_PRODUCTION_API }}/api
          REACT_APP_ENVIRONMENT: production
          # Add other frontend environment variables as needed
        run: |
          echo "Building frontend for production..."
          npm install --no-fund --no-audit
          DISABLE_ESLINT_PLUGIN=true CI=false npm run build
          echo "Frontend build completed"

      - name: Build API for production
        working-directory: ./API
        run: |
          echo "Building API for production..."
          npm install --production --no-fund --no-audit
          echo "API build completed"

      - name: Create production .env file
        working-directory: ./API
        run: |
          echo "Creating production .env file..."
          cat > .env << EOF
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_USERNAME=${{ secrets.DATABASE_USERNAME }}
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=${{ secrets.DATABASE_NAME }}
          DATABASE_PORT=${{ secrets.DATABASE_PORT }}
          API_PORT=${{ secrets.API_PORT }}
          TOMTOMAPI=${{ secrets.TOMTOMAPI }}
          WEATHERAPI=${{ secrets.WEATHERAPI }}
          CORS_ORIGIN=http://localhost:3000/
          USE_CALIFORNIA_TRAFFIC=true
          PEMS_USERNAME=${{ secrets.PEMS_USERNAME }}
          PEMS_PASSWORD=${{ secrets.PEMS_PASSWORD }}
          TRAFFIC_511_API_TOKEN=${{ secrets.TRAFFIC_511_API_TOKEN }}
          NODE_ENV=production
          EOF
          echo "Production .env file created with all required variables"

      - name: Create production deployment artifacts
        run: |
          echo "Creating production deployment artifacts..."
          mkdir -p dist
          
          # Create version info
          echo "$(date +'%Y%m%d%H%M%S')-${GITHUB_SHA::8}" > dist/version.txt
          
          # Frontend artifacts
          mkdir -p dist/frontend
          if [ -d "frontend/build" ]; then
            cp -r frontend/build/* dist/frontend/
            echo "Frontend artifacts created"
          else
            echo "Frontend build not found"
            exit 1
          fi
          
          # API artifacts
          mkdir -p dist/api
          cp -r API/* dist/api/
          echo "API artifacts created"
          
          echo "All deployment artifacts ready"

      # Deploy Frontend to S3 (Production) - Using supported S3 sync action
      - name: Deploy Frontend to S3 Production
        uses: jakejarvis/s3-sync-action@v0.5.1
        with:
          args: --delete
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_PRODUCTION_BUCKET }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          SOURCE_DIR: dist/frontend

      # API deployment to a EC2 (staging) was removed as we are restricted to free tier
      # Deploy API to EC2 (Production) - FREE TIER: Use t2.micro instance only
      - name: Deploy API to EC2 Production
        run: |
          echo "===== DEPLOYING API TO EC2 PRODUCTION INSTANCE ====="
          echo " NOTE: Using t3.micro instance (better performance than t2.micro, still free tier eligible)"
          
          # Setup SSH key from secret
          echo "Setting up SSH key..."
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/ec2_key.pem
          chmod 600 ~/.ssh/ec2_key.pem
          
          # Create deployment package
          cd dist/api
          tar -czf ../api-deployment.tar.gz .
          cd ../..
          
          # Copy to EC2 instance
          echo "Copying API files to EC2 production instance..."
          scp -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no \
            dist/api-deployment.tar.gz \
            ubuntu@ec2-54-224-228-41.compute-1.amazonaws.com:/tmp/
          
          # Deploy on EC2 instance
          ssh -i ~/.ssh/ec2_key.pem -o StrictHostKeyChecking=no \
            ubuntu@ec2-54-224-228-41.compute-1.amazonaws.com << 'EOF'
            
            echo "Starting API deployment..."
            
            # Stop existing API processes
            echo "Stopping existing API..."
            screen -S api -X quit 2>/dev/null || true
            pkill -f "node src/server.js" 2>/dev/null || true
            sleep 3
            
            # Navigate to API directory
            cd /var/www/api
            
            # Backup current version
            if [ -d "API" ]; then
              echo "Backing up current API..."
              sudo rm -rf API_backup 2>/dev/null || true
              sudo cp -r API API_backup
            fi
            
            # Create fresh API directory
            sudo rm -rf API
            sudo mkdir -p API
            cd API
            
            # Extract new deployment
            echo "Extracting new API version..."
            sudo tar -xzf /tmp/api-deployment.tar.gz
            sudo chown -R ubuntu:ubuntu /var/www/api/API
            
            # Restore .env file if it exists
            if [ -f "../API_backup/.env" ]; then
              echo "Restoring .env file..."
              cp ../API_backup/.env .env
            else
              echo "WARNING: No .env file found in backup!"
            fi
            
            # Install dependencies
            echo "Installing dependencies..."
            npm install --omit=dev --no-fund --no-audit
            
            # Verify entry point exists
            if [ ! -f "src/server.js" ]; then
              echo "ERROR: src/server.js not found!"
              ls -la src/ || echo "src directory not found"
              exit 1
            fi
            
            # Start API in screen session
            echo "Starting API in screen session..."
            screen -dmS api bash -c 'cd /var/www/api/API && npm start'
            
            # Wait and verify
            sleep 10
            
            # Check if screen session is running
            if screen -list | grep -q "api"; then
              echo "Screen session started successfully"
              
              # Test API response
              sleep 5
              if curl -f -s http://localhost:5000 >/dev/null 2>&1; then
                echo "API is responding on port 5000"
              else
                echo "API started but not yet responding (may need more startup time)"
              fi
            else
              echo "Failed to start screen session"
              
              # Try to see what went wrong
              echo "Checking for any error logs..."
              tail -20 /var/log/nginx/error.log 2>/dev/null || echo "No nginx error log available"
              
              # Attempt rollback
              echo "Attempting rollback..."
              cd /var/www/api
              if [ -d "API_backup" ]; then
                sudo rm -rf API
                sudo mv API_backup API
                cd API
                screen -dmS api bash -c 'npm start'
                echo "Rollback attempted"
              fi
              exit 1
            fi
            
            # Cleanup
            rm -f /tmp/api-deployment.tar.gz
            
            echo "API deployment completed successfully"
          EOF
          
          # Clean up SSH key
          rm -f ~/.ssh/ec2_key.pem
          
          echo "API deployment finished"

  post-deployment-monitoring:
    name: Post-Deployment Monitoring
    needs: [deploy-production]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Dynamic ref based on trigger type - ensures we get the right commit
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}

      - name: Initial Health Check
        run: |
          echo "Running post-deployment health verification..."
          
          # Test S3 static website hosting
          echo "Checking Frontend (S3 Static Website)..."
          FRONTEND_URL="https://trafficguardian.co.za"
          if curl -f -s --head "$FRONTEND_URL" > /dev/null; then
            echo "Frontend: HEALTHY"
          else
            echo "Frontend: Could not verify"
          fi
          
          # Test API health endpoint
          echo "Checking API (EC2)..."
          API_URL="https://${{ secrets.EC2_PRODUCTION_API }}/api/health"
          if curl -f -s "$API_URL" | grep -q '"status":"OK"' 2>/dev/null; then
            echo "API: HEALTHY"
          else
            echo "API: Could not verify health endpoint"
            # Try basic connection test
            if curl -f -s "https://${{ secrets.EC2_PRODUCTION_API }}/" > /dev/null; then
              echo "API: Server responding"
            fi
          fi
          
          echo "Health verification completed"

      - name: Performance Check
        run: |
          echo "Running basic performance checks..."
          
          # Test API response time
          API_URL="https://${{ secrets.EC2_PRODUCTION_API }}/api/health"
          RESPONSE_TIME=$(curl -f -s -w "%{time_total}" -o /dev/null "$API_URL" 2>/dev/null || echo "0")
          
          if [ "$RESPONSE_TIME" != "0" ]; then
            echo "API response time: ${RESPONSE_TIME}s"
            # Simple performance check using shell arithmetic
            RESPONSE_INT=$(echo "$RESPONSE_TIME" | cut -d'.' -f1)
            if [ "$RESPONSE_INT" -eq 0 ]; then
              echo "Performance: Excellent (< 1s)"
            else
              echo "Performance: Could be improved (> 1s)"
            fi
          else
            echo "Could not measure API response time"
          fi

      - name: Generate Monitoring Summary
        run: |
          echo "===== MONITORING SETUP COMPLETE ====="
          echo "Production system is now being monitored"
          echo ""
          echo "Key Endpoints:"
          echo "   Frontend: S3 Static Website (URL in environment variables)"
          echo "   API Health: Production API Health Endpoint"
          echo ""
          echo "Recommended monitoring setup:"
          echo "   • Set up external uptime monitoring (e.g., UptimeRobot, Pingdom)"
          echo "   • Configure CloudWatch alarms for EC2 instance metrics"
          echo "   • Set up log aggregation for application logs"
          echo "   • Monitor API response times and error rates"